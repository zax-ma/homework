package home_work_1;

import javax.swing.*;

public class Priority {
    public static void main(String[] args){

        //2.1 5 + 2 / 8
        int exmpl1 = 5+2/8;
        System.out.println("5 + 2 / 8 = "+exmpl1);
        /*
         1)деление: 2/8 = 0.25, но тк это тип int, то 2/8 = 0,
         2) сложение 5+0 = 5, (idea посчитала 2/8 лишним действием)
         */

        // 2.2 (5 + 2) / 8
        int exmpl2 = ((5+2)/8);
        System.out.println("(5 + 2) / 8 = "+exmpl2);
        /*
         1) скобки: 5+2=7
         2) деление: 7/8=0.85, но тк int, результат = 0, (idea предлагает заменить все на 0 без лишних вычислений)
          */

        // 2.3 (5 + 2++) / 8
        int a = 2;
        int exmpl3 = (5+a++)/8;
        System.out.println("(5 + 2++) / 8 = "+exmpl3);
        /*
        1) скобки
        2) инкремент 2++: 2, a=3
         Первый результат будет 0, тк в первом действии инкрементации идет увеличение первоначальной переменной, без участия в
         операции сложения (останется 2 на месте a++, но переменная a изменит значение на 3), все последующие вызовы кода будут увеличивать a на 1.
        3) сложение: 5+2=7
        4) деление: 7/8=0.85, но тк int, результат = 0, (idea предлагает заменить все на 0 без лишних вычислений)
          */

        // 2.4 (5 + 2++) / --8
        int b = 2;
        int c = 8;
        int exmlp4 = ((5 + b++) / --c);
        System.out.println("(5 + 2++) / --8 = "+exmlp4);
         /*
         1) скобки
         2) инкремент 2++ = 2, b=3
         3) сложение 5+2=7
         4) инкремент --8 = 7
        Выполнение по порядку b++ из предыдущего примера, даст 3+1=4 и запишет 4 в переменную b, в подсчете участвует предыдущее значение b - 3 (5+3=8),
        следующим исполняется инкремент --с (с = 8, 8-1=7, переменная с получает значение 7)
         5) деление 7/7 = 1
         */

        //2.5 (5 * 2 >> 2++) / --8
        int d = 2;
        int e = 8;
        int exmpl5 = ((5 * d >> d++) / --e);
        System.out.println("(5 * 2 >> 2++) / --8 = "+exmpl5);
        /*
        1) скобки
        2) инкремент 2++ = 2, в d=3
        3) умножение: 5*3 = 15
        4) сдвиг 15 вправо на 2 = 3
        5) инкремент --8 = 7
        5) деление 3/8 = 0
         */

       //2.6 (5 + 7 > 20 ? 68 : 22 * 2 >> 2++) / --8
        boolean logic = 5+7>20;
        int f = 2;
        int g = 8;
        int exmpl6 = (logic ? 68 : 22 * 2 >> f++) / --g;
        System.out.println("(5 + 7 > 20 ? 68 : 22 * 2 >> 2++) / --8 = "+exmpl6);
        /*
        1) скобки
        2) инкремент 2++ = 2, f = 3
        3) умножение 22*2 = 44
        4) сдвиг 44 >> 2 = 11
        5) тернарный оператр ( логическое условие ? выражение1(если true) : выражение2(если false)
            false ? 68 : 11 = 11
        6) --8 = 7
        7) 11/7 = 1.57.., но тк int, exmpl6=1
        */

        //2.7 (5 + 7 > 20 ? 68 >= 68 : 22 * 2 >> 2++) / --8
        boolean logic2 = 5+7>20;
        int logic3 = (68 >= 68) ? 1 : 0;
        int h = 2;
        int i = 8;
        int exmpl7 = (logic2 ? logic3 : 22 * 2 >> h++) / --i;
        System.out.println("(5 + 7 > 20 ? 68 >= 68 : 22 * 2 >> 2++) / --8 = "+exmpl7);
        /*
        1) скобки
        2) инкремент 2++ = 2, f = 3
        3) умножение 22*2 = 44
        4) сдвиг 44 >> 2 = 11
        5) тернарный оператр ( логическое условие ? выражение1(если true) : выражение2(если false) (boolean ? int : int)
            false ? ((68 >= 68) ? 1 : 0) : 11 = 11
        6) --8 = 7
        7) 11/7 = 1.57.., но тк int, exmpl7=1
         */

        //2.8 6 - 2 > 3 && 12 * 12 <= 119
        boolean frst_expr = 6 - 2 > 3;
        boolean scnd_expr = 12 * 12 <= 119;
        boolean exmpl8 = frst_expr && scnd_expr;
        System.out.println("6 - 2 > 3 && 12 * 12 <= 119 = "+exmpl8);
        /*
        1) умножение 12 * 12 = 144
        2) вычитание 6 - 2 = 4
        3) сравнение 4 > 3 = true
        4) сравнение 144 <= 119 = false
        5) логическое И true && false = false
         */

        //2.9 true && false
        System.out.println("true && false = "+String.valueOf(true && false));
        // 1) оператор && принимает true, только в случае, если правая и левая часть возвращают одинаковое значение: true или false
    }
}
